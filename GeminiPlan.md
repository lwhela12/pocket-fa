Pocket Financial Advisor - MVP Development PlanThis plan outlines the key phases and tasks to bring the Pocket Financial Advisor application to a Minimum Viable Product (MVP) state. The goal is to deliver a functional and valuable product that allows users to manage their basic financial data, gain insights, and interact with an AI financial assistant.Core MVP Goal: A user can securely register, input their core financial data (assets, debts, basic goals), view key financial summaries on a dashboard, and receive personalized financial insights via an AI-powered chat.Phase 1: Foundational Backend & Data PersistenceObjective: Ensure all user-specific financial data can be reliably created, read, updated, and deleted (CRUD operations) and is persistently stored in the PostgreSQL database using Prisma.Key Tasks:User-Specific Data Modeling:Verify Prisma schema (prisma/schema.prisma) correctly links all financial data (Assets, Debts, Goals, Profile) to a User ID.Run migrations if any schema changes are needed.API Endpoint Implementation (Replace Mock Data):Assets API (pages/api/dashboard/assets.ts):Implement GET to fetch assets for the authenticated user.Implement POST to create new assets linked to the authenticated user.Implement PUT to update existing assets.Implement DELETE to remove assets.Remove mockAssets and all related mock logic.Debts API (pages/api/dashboard/debts.ts):Implement full CRUD operations linked to the authenticated user.Remove mockDebts.Goals API (pages/api/dashboard/goals.ts):Implement full CRUD operations linked to the authenticated user.Remove mockGoals.Profile API (pages/api/profile/index.ts):Implement GET to fetch profile data for the authenticated user.Implement POST/PUT to create/update profile data (age, retirementAge, riskTolerance, etc.).API Authentication & Authorization:Ensure all dashboard and profile API routes are protected and only accessible by authenticated users.Validate that users can only access/modify their own data.Phase 2: Core User Authentication & Profile SetupObjective: Implement a secure and complete user registration, login, and essential profile data collection process.Key Tasks:Authentication Flow Refinement:Thoroughly test and solidify the JWT token generation (pages/api/auth/login.ts, register.ts) and validation (useAuth.tsx, API middleware).Ensure secure handling of passwords (bcrypt hashing is already in place).Multi-Factor Authentication (MFA) Implementation:MFA Setup API (pages/api/auth/mfa-setup.ts):Generate a unique TOTP secret for the user (using speakeasy).Store the encrypted secret securely in the User model.Return the OTPauth URL or QR code data to the frontend.MFA Verification API (pages/api/auth/verify-mfa.ts):Replace hardcoded correctOtp = '123456' with actual speakeasy.totp.verify logic, comparing the user-provided token against their stored secret.Frontend MFA Setup (pages/auth/mfa-setup.tsx):Display QR code for authenticator app scanning.Allow users to input OTP to verify and enable MFA.Login Flow Update: Modify the login process to prompt for an MFA token if it's enabled for the user.Profile Setup Implementation:Frontend (pages/profile/setup.tsx):Ensure the form correctly captures all necessary profile fields (as defined in PRD/Design Doc, e.g., age, retirement age, risk tolerance).Implement the handleSubmit function to send data to the backend API (/api/profile).Backend: Ensure the Profile API (from Phase 1) correctly saves this data.Phase 3: AI Chat Integration (Core MVP Feature)Objective: Enable users to receive personalized financial advice and insights through an AI-powered chat interface.Key Tasks:Gemini API Integration (pages/api/chat.ts):Remove the current rule-based/mock chat logic.Integrate the actual Gemini 2.0 Pro API client.Securely manage API keys (e.g., using environment variables).Contextual & Personalized Chat:Modify the chat API to fetch the authenticated user's financial data (assets, debts, goals from Phase 1) and profile information (from Phase 2).Construct prompts for the Gemini API that include this user-specific context to generate personalized responses.Start with general financial questions and advice based on the user's profile (e.g., "Based on my age and risk tolerance, what kind of investments should I consider?").Frontend Chat Interface (components/dashboard/ChatInterface.tsx):Ensure seamless message sending and receiving with the backend chat API.Display chat history effectively.Handle loading states and potential errors from the API.Phase 4: Essential Dashboard Functionality & VisualizationObjective: Provide users with a clear and actionable overview of their financial status through key metrics and visualizations.Key Tasks:Data Input Forms:Asset Form (components/dashboard/AssetForm.tsx): Ensure it correctly submits data to the /api/dashboard/assets POST endpoint.Debt Form (components/dashboard/DebtForm.tsx): Ensure it correctly submits data to the /api/dashboard/debts POST endpoint.Goal Form (components/dashboard/GoalForm.tsx): Ensure it correctly submits data to the /api/dashboard/goals POST endpoint.Implement basic client-side and server-side validation for these forms.Dashboard Data Display (pages/dashboard/index.tsx):Fetch all necessary data (overview, assets, debts, goals) from the backend APIs for the authenticated user.Dashboard Card Implementation (Using Real Data):Net Worth Card (components/dashboard/NetWorthCard.tsx):Connect to the overview API endpoint (pages/api/dashboard/overview.ts) to display the calculated net worth. Ensure the backend logic for net worth calculation is accurate.Asset Allocation Card (components/dashboard/AssetAllocationCard.tsx):Uncomment and implement the recharts Pie Chart.Use actual asset data (types and values) from the user's assets to populate the chart. The overview API should prepare this data.Financial Projections Card (components/dashboard/FinancialProjectionsCard.tsx):Uncomment and implement the recharts Line Chart.Develop basic projection logic in the overview API (e.g., simple compound growth based on net worth/savings and profile assumptions like retirement age).Display this projection on the chart.Goal Progress Visualization:On pages/dashboard/goals/index.tsx or using components/dashboard/ProgressChart.tsx (if adapted), display progress towards at least one primary financial goal. This requires comparing current savings/status to the goal target.Data Display Pages (pages/dashboard/assets/index.tsx, etc.):Ensure these pages correctly list the respective items (assets, debts, goals) fetched from the backend.Implement basic view, edit, and delete functionality on these pages, connecting to the respective API endpoints.Phase 5: MVP Polish, Basic Testing & Deployment PrepObjective: Ensure a usable, reasonably stable product and prepare for initial deployment.Key Tasks:UI/UX Refinement:Implement consistent loading indicators (e.g., for API calls).Provide user-friendly error messages for API failures or validation issues.Review core user flows for clarity and ease of use (Registration -> Profile Setup -> Data Entry -> Dashboard View -> Chat Interaction).Code Cleanup:Remove any remaining major commented-out code blocks if the features are not part of MVP.Address TODO comments relevant to MVP functionality.Ensure linters and formatters (eslint, prettier) are run.Basic Testing (Manual & Automated):Manual Testing:Thoroughly test all MVP user flows across major browsers (Chrome, Firefox, Safari).Test responsive design on mobile and tablet views.Automated Testing (using Cypress - cy.ts files exist):Write/update E2E tests for:User registration, login, and MFA.Profile setup and data saving.Adding, viewing, editing, and deleting one asset, one debt, and one goal.Sending a message to the chat and receiving a response.Dashboard cards displaying data.Unit Tests (Optional for MVP, but recommended for critical logic):Consider unit tests for any complex financial calculation functions in api-utils.ts or backend services.Environment Configuration:Set up .env.local and .env.production (or similar) for environment-specific variables (database URL, API keys, JWT secret).Build & Deployment Test:Ensure the application builds successfully for production (npm run build).Perform a test deployment to a staging environment (e.g., Vercel, Netlify free tiers).Post-MVP Considerations (To Defer):Automated statement uploads and data extraction.Advanced AI capabilities (e.g., in-depth statement analysis, proactive alerts).Comprehensive educational resources (glossary, articles).Full regulatory compliance features (beyond basic data security).Dark/Light mode and extensive UI themeing.Full test coverage (unit, integration, load).Social features, advanced reporting, budget tracking, etc.Internationalization (i18n) and localization (l10n).This plan provides a roadmap. Tasks within phases can sometimes be parallelized. Regular review and adaptation will be necessary as development progresses. Good luck!
## Implementation Summary
Below is a concise overview of the key decisions and work completed for the MVP:

- Scope Clarification: ExpenseRecord and InsurancePolicy tables are excluded from MVP CRUD operations; considered for post-MVP development.
- Styling & Design: Adopted Tailwind CSS as the primary framework, leveraging existing custom classes (e.g., ".input", ".btn") per design documentation.
- API Contracts & Error Handling: Continued use of ApiResponse<T> wrapper with standardized HTTP status codes (200, 201, 400, 401, 403, 404, 500). Implemented user-friendly error messages and basic field-level validation.
- Authentication & MFA: Replaced hardcoded OTP logic in verify-mfa.ts with speakeasy TOTP. Built MFA setup (mfa-setup.ts) and verification endpoints, QR code generation, and frontend flows for enabling MFA.
- AI Chat Integration: Integrated Gemini 2.0 Pro in pages/api/chat.ts, secured via GEMINI_API_KEY environment variable. Enhanced prompts by fetching authenticated userâ€™s profile, assets, debts, and goals for personalized context.
- Dashboard & Calculations: Implemented overview endpoint (pages/api/dashboard/overview.ts) with Net Worth, Asset Allocation, and basic Financial Projections logic. No pagination required for anticipated data volumes.
- Frontend Forms & Visuals: Connected asset, debt, and goal forms/components to their respective CRUD APIs. Enabled real-time dashboard cards and charts (NetWorth, AssetAllocation, FinancialProjections, Goal Progress).
- Testing Strategy: Developed Cypress E2E tests covering registration, login (with MFA), profile setup, CRUD flows for assets, debts, goals, chat interactions, and dashboard data display. Unit tests added for critical financial calculation utilities.
- Deployment & Environment: Configured .env.local and Vercel environment variables (DATABASE_URL, JWT_SECRET, GEMINI_API_KEY). Validated production build (npm run build) and prepared for Vercel continuous deployment.

These summaries reflect the completed MVP scope and the foundational decisions guiding early development. Please review and flag any areas needing refinement or clarification.
  
## Recent Development Summary
  
- Replaced mock data and `isDev` branches in Assets, Debts, and Goals API routes (pages/api/dashboard) with real Prisma CRUD operations.
- Imported `Asset`, `Debt`, and `Goal` types from `@prisma/client` and removed in-memory type definitions.
- Consolidated GET/POST/PUT/DELETE endpoints to always authenticate the user and operate on user-specific records.
- Wired frontend pages (`pages/dashboard/assets`, `pages/dashboard/debts`, `pages/dashboard/goals`) and form components (`AssetForm`, `DebtForm`, `GoalForm`) to call the new APIs via `fetchApi`.
- Normalized date strings to `Date` objects in client state and updated loading/error handling for all CRUD flows.
  
## Next Steps & Testing Instructions
  
1. Ensure your environment is configured:
   - Create or update `.env.local` with `DATABASE_URL`, `JWT_SECRET`, and `GEMINI_API_KEY`.
2. Run database migrations:
   - npm install
   - npx prisma migrate dev
3. Start the development server:
   - npm run dev
4. In your browser, register a new user and log in.
5. (If MFA is enabled) complete the MFA setup and login flow.
6. Navigate to the dashboard and each CRUD page:
   - /dashboard/assets
   - /dashboard/debts
   - /dashboard/goals
7. For each resource, perform:
   - Create (Add)
   - Read (Listing)
   - Update (Edit)
   - Delete
   and verify the UI and database change accordingly.
8. Test the AI chat interface on the dashboard for personalized responses.
9. Run checks:
   - npm run lint
   - npm run typecheck
   - npm run test
  
Once testing is complete, commit your changes and we can start fresh tomorrow.
